/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.io.lightcone.data.types.Account', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.AccountID', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Address', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Amount', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Bips', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.CursorPaging', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.EdDSAPrivKey', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.EdDSAPubKey', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.EdDSASignature', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Error', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.ErrorCode', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Interval', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Market', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.MarketMetadata', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.MarketMetadata.Status', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.MarketTicker', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.MiMCHash', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Nonce', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.OrderID', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.OrderStatus', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Percentage', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Proof', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.SHA256Hash', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.Token', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TokenID', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TokenInfo', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TokenMetadata', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TokenMetadata.Type', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TokenTicker', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.TxData', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.UserTxStatus', null, global);
goog.exportSymbol('proto.io.lightcone.data.types.UserTxType', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.AccountID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.AccountID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.AccountID.displayName = 'proto.io.lightcone.data.types.AccountID';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.AccountID.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.AccountID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.AccountID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.AccountID.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.AccountID}
 */
proto.io.lightcone.data.types.AccountID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.AccountID;
  return proto.io.lightcone.data.types.AccountID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.AccountID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.AccountID}
 */
proto.io.lightcone.data.types.AccountID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.AccountID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.AccountID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.AccountID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.AccountID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.AccountID.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.AccountID.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.TokenID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.TokenID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.TokenID.displayName = 'proto.io.lightcone.data.types.TokenID';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.TokenID.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.TokenID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.TokenID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenID.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.TokenID}
 */
proto.io.lightcone.data.types.TokenID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.TokenID;
  return proto.io.lightcone.data.types.TokenID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.TokenID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.TokenID}
 */
proto.io.lightcone.data.types.TokenID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.TokenID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.TokenID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.TokenID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenID.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenID.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.OrderID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.OrderID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.OrderID.displayName = 'proto.io.lightcone.data.types.OrderID';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.OrderID.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.OrderID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.OrderID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.OrderID.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.OrderID}
 */
proto.io.lightcone.data.types.OrderID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.OrderID;
  return proto.io.lightcone.data.types.OrderID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.OrderID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.OrderID}
 */
proto.io.lightcone.data.types.OrderID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.OrderID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.OrderID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.OrderID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.OrderID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.OrderID.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.OrderID.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Amount = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Amount, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Amount.displayName = 'proto.io.lightcone.data.types.Amount';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Amount.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Amount.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Amount} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Amount.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Amount}
 */
proto.io.lightcone.data.types.Amount.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Amount;
  return proto.io.lightcone.data.types.Amount.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Amount} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Amount}
 */
proto.io.lightcone.data.types.Amount.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Amount.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Amount.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Amount} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Amount.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.Amount.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.io.lightcone.data.types.Amount.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Amount.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.Amount.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Address = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Address, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Address.displayName = 'proto.io.lightcone.data.types.Address';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Address.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Address.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Address} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Address.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Address}
 */
proto.io.lightcone.data.types.Address.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Address;
  return proto.io.lightcone.data.types.Address.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Address} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Address}
 */
proto.io.lightcone.data.types.Address.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Address.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Address.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Address} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Address.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string value = 1;
 * @return {string}
 */
proto.io.lightcone.data.types.Address.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.Address.prototype.setValue = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.TxData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.TxData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.TxData.displayName = 'proto.io.lightcone.data.types.TxData';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.TxData.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.TxData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.TxData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TxData.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.TxData}
 */
proto.io.lightcone.data.types.TxData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.TxData;
  return proto.io.lightcone.data.types.TxData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.TxData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.TxData}
 */
proto.io.lightcone.data.types.TxData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.TxData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.TxData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.TxData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TxData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string value = 1;
 * @return {string}
 */
proto.io.lightcone.data.types.TxData.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TxData.prototype.setValue = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Nonce = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Nonce, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Nonce.displayName = 'proto.io.lightcone.data.types.Nonce';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Nonce.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Nonce.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Nonce} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Nonce.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Nonce}
 */
proto.io.lightcone.data.types.Nonce.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Nonce;
  return proto.io.lightcone.data.types.Nonce.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Nonce} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Nonce}
 */
proto.io.lightcone.data.types.Nonce.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Nonce.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Nonce.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Nonce} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Nonce.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.Nonce.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.Nonce.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Bips = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Bips, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Bips.displayName = 'proto.io.lightcone.data.types.Bips';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Bips.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Bips.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Bips} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Bips.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Bips}
 */
proto.io.lightcone.data.types.Bips.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Bips;
  return proto.io.lightcone.data.types.Bips.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Bips} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Bips}
 */
proto.io.lightcone.data.types.Bips.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Bips.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Bips.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Bips} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Bips.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.Bips.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.Bips.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Percentage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Percentage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Percentage.displayName = 'proto.io.lightcone.data.types.Percentage';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Percentage.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Percentage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Percentage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Percentage.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Percentage}
 */
proto.io.lightcone.data.types.Percentage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Percentage;
  return proto.io.lightcone.data.types.Percentage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Percentage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Percentage}
 */
proto.io.lightcone.data.types.Percentage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Percentage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Percentage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Percentage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Percentage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 value = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.Percentage.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.Percentage.prototype.setValue = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.MiMCHash = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.MiMCHash, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.MiMCHash.displayName = 'proto.io.lightcone.data.types.MiMCHash';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.MiMCHash.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.MiMCHash.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.MiMCHash} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MiMCHash.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.MiMCHash}
 */
proto.io.lightcone.data.types.MiMCHash.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.MiMCHash;
  return proto.io.lightcone.data.types.MiMCHash.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.MiMCHash} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.MiMCHash}
 */
proto.io.lightcone.data.types.MiMCHash.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.MiMCHash.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.MiMCHash.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.MiMCHash} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MiMCHash.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.MiMCHash.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.io.lightcone.data.types.MiMCHash.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.MiMCHash.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.MiMCHash.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.SHA256Hash = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.SHA256Hash, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.SHA256Hash.displayName = 'proto.io.lightcone.data.types.SHA256Hash';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.SHA256Hash.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.SHA256Hash.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.SHA256Hash} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.SHA256Hash.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.SHA256Hash}
 */
proto.io.lightcone.data.types.SHA256Hash.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.SHA256Hash;
  return proto.io.lightcone.data.types.SHA256Hash.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.SHA256Hash} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.SHA256Hash}
 */
proto.io.lightcone.data.types.SHA256Hash.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.SHA256Hash.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.SHA256Hash.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.SHA256Hash} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.SHA256Hash.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.SHA256Hash.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.io.lightcone.data.types.SHA256Hash.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.SHA256Hash.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.SHA256Hash.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Proof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.io.lightcone.data.types.Proof.repeatedFields_, null);
};
goog.inherits(proto.io.lightcone.data.types.Proof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Proof.displayName = 'proto.io.lightcone.data.types.Proof';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.io.lightcone.data.types.Proof.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Proof.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Proof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Proof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Proof.toObject = function(includeInstance, msg) {
  var f, obj = {
    dataList: jspb.Message.toObjectList(msg.getDataList(),
    proto.io.lightcone.data.types.MiMCHash.toObject, includeInstance),
    costSeconds: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Proof}
 */
proto.io.lightcone.data.types.Proof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Proof;
  return proto.io.lightcone.data.types.Proof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Proof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Proof}
 */
proto.io.lightcone.data.types.Proof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.io.lightcone.data.types.MiMCHash;
      reader.readMessage(value,proto.io.lightcone.data.types.MiMCHash.deserializeBinaryFromReader);
      msg.addData(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCostSeconds(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Proof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Proof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Proof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Proof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDataList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.io.lightcone.data.types.MiMCHash.serializeBinaryToWriter
    );
  }
  f = message.getCostSeconds();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * repeated MiMCHash data = 1;
 * @return {!Array<!proto.io.lightcone.data.types.MiMCHash>}
 */
proto.io.lightcone.data.types.Proof.prototype.getDataList = function() {
  return /** @type{!Array<!proto.io.lightcone.data.types.MiMCHash>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.io.lightcone.data.types.MiMCHash, 1));
};


/** @param {!Array<!proto.io.lightcone.data.types.MiMCHash>} value */
proto.io.lightcone.data.types.Proof.prototype.setDataList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.io.lightcone.data.types.MiMCHash=} opt_value
 * @param {number=} opt_index
 * @return {!proto.io.lightcone.data.types.MiMCHash}
 */
proto.io.lightcone.data.types.Proof.prototype.addData = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.io.lightcone.data.types.MiMCHash, opt_index);
};


proto.io.lightcone.data.types.Proof.prototype.clearDataList = function() {
  this.setDataList([]);
};


/**
 * optional uint64 cost_seconds = 2;
 * @return {number}
 */
proto.io.lightcone.data.types.Proof.prototype.getCostSeconds = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.Proof.prototype.setCostSeconds = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.EdDSAPrivKey = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.EdDSAPrivKey, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.EdDSAPrivKey.displayName = 'proto.io.lightcone.data.types.EdDSAPrivKey';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.EdDSAPrivKey.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.EdDSAPrivKey} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSAPrivKey.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.EdDSAPrivKey}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.EdDSAPrivKey;
  return proto.io.lightcone.data.types.EdDSAPrivKey.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.EdDSAPrivKey} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.EdDSAPrivKey}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.EdDSAPrivKey.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.EdDSAPrivKey} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSAPrivKey.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSAPrivKey.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.EdDSAPubKey = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.EdDSAPubKey, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.EdDSAPubKey.displayName = 'proto.io.lightcone.data.types.EdDSAPubKey';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.EdDSAPubKey.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.EdDSAPubKey} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSAPubKey.toObject = function(includeInstance, msg) {
  var f, obj = {
    x: msg.getX_asB64(),
    y: msg.getY_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.EdDSAPubKey}
 */
proto.io.lightcone.data.types.EdDSAPubKey.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.EdDSAPubKey;
  return proto.io.lightcone.data.types.EdDSAPubKey.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.EdDSAPubKey} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.EdDSAPubKey}
 */
proto.io.lightcone.data.types.EdDSAPubKey.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setX(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setY(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.EdDSAPubKey.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.EdDSAPubKey} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSAPubKey.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getX_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getY_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes x = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getX = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes x = 1;
 * This is a type-conversion wrapper around `getX()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getX_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getX()));
};


/**
 * optional bytes x = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getX()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getX_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getX()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.setX = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes y = 2;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getY = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes y = 2;
 * This is a type-conversion wrapper around `getY()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getY_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getY()));
};


/**
 * optional bytes y = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getY()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.getY_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getY()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSAPubKey.prototype.setY = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.EdDSASignature = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.EdDSASignature, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.EdDSASignature.displayName = 'proto.io.lightcone.data.types.EdDSASignature';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.EdDSASignature.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.EdDSASignature} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSASignature.toObject = function(includeInstance, msg) {
  var f, obj = {
    rx: msg.getRx_asB64(),
    ry: msg.getRy_asB64(),
    s: msg.getS_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.EdDSASignature}
 */
proto.io.lightcone.data.types.EdDSASignature.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.EdDSASignature;
  return proto.io.lightcone.data.types.EdDSASignature.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.EdDSASignature} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.EdDSASignature}
 */
proto.io.lightcone.data.types.EdDSASignature.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRx(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRy(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setS(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.EdDSASignature.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.EdDSASignature} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.EdDSASignature.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRx_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getRy_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getS_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional bytes rx = 1;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRx = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes rx = 1;
 * This is a type-conversion wrapper around `getRx()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRx_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRx()));
};


/**
 * optional bytes rx = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRx()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRx_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRx()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSASignature.prototype.setRx = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes ry = 2;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRy = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes ry = 2;
 * This is a type-conversion wrapper around `getRy()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRy_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRy()));
};


/**
 * optional bytes ry = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRy()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getRy_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRy()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSASignature.prototype.setRy = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes s = 3;
 * @return {!(string|Uint8Array)}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getS = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes s = 3;
 * This is a type-conversion wrapper around `getS()`
 * @return {string}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getS_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getS()));
};


/**
 * optional bytes s = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getS()`
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.EdDSASignature.prototype.getS_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getS()));
};


/** @param {!(string|Uint8Array)} value */
proto.io.lightcone.data.types.EdDSASignature.prototype.setS = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.CursorPaging = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.CursorPaging, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.CursorPaging.displayName = 'proto.io.lightcone.data.types.CursorPaging';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.CursorPaging.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.CursorPaging.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.CursorPaging} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.CursorPaging.toObject = function(includeInstance, msg) {
  var f, obj = {
    num: jspb.Message.getFieldWithDefault(msg, 1, 0),
    cursor: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.CursorPaging}
 */
proto.io.lightcone.data.types.CursorPaging.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.CursorPaging;
  return proto.io.lightcone.data.types.CursorPaging.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.CursorPaging} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.CursorPaging}
 */
proto.io.lightcone.data.types.CursorPaging.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNum(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCursor(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.CursorPaging.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.CursorPaging.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.CursorPaging} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.CursorPaging.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNum();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getCursor();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional uint32 num = 1;
 * @return {number}
 */
proto.io.lightcone.data.types.CursorPaging.prototype.getNum = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.CursorPaging.prototype.setNum = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 cursor = 2;
 * @return {number}
 */
proto.io.lightcone.data.types.CursorPaging.prototype.getCursor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.CursorPaging.prototype.setCursor = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Account = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Account, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Account.displayName = 'proto.io.lightcone.data.types.Account';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Account.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Account.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Account} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Account.toObject = function(includeInstance, msg) {
  var f, obj = {
    owner: (f = msg.getOwner()) && proto.io.lightcone.data.types.Address.toObject(includeInstance, f),
    pubKey: (f = msg.getPubKey()) && proto.io.lightcone.data.types.EdDSAPubKey.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Account}
 */
proto.io.lightcone.data.types.Account.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Account;
  return proto.io.lightcone.data.types.Account.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Account} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Account}
 */
proto.io.lightcone.data.types.Account.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.io.lightcone.data.types.Address;
      reader.readMessage(value,proto.io.lightcone.data.types.Address.deserializeBinaryFromReader);
      msg.setOwner(value);
      break;
    case 2:
      var value = new proto.io.lightcone.data.types.EdDSAPubKey;
      reader.readMessage(value,proto.io.lightcone.data.types.EdDSAPubKey.deserializeBinaryFromReader);
      msg.setPubKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Account.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Account.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Account} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Account.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getOwner();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.io.lightcone.data.types.Address.serializeBinaryToWriter
    );
  }
  f = message.getPubKey();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.io.lightcone.data.types.EdDSAPubKey.serializeBinaryToWriter
    );
  }
};


/**
 * optional Address owner = 1;
 * @return {?proto.io.lightcone.data.types.Address}
 */
proto.io.lightcone.data.types.Account.prototype.getOwner = function() {
  return /** @type{?proto.io.lightcone.data.types.Address} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.Address, 1));
};


/** @param {?proto.io.lightcone.data.types.Address|undefined} value */
proto.io.lightcone.data.types.Account.prototype.setOwner = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.io.lightcone.data.types.Account.prototype.clearOwner = function() {
  this.setOwner(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Account.prototype.hasOwner = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional EdDSAPubKey pub_key = 2;
 * @return {?proto.io.lightcone.data.types.EdDSAPubKey}
 */
proto.io.lightcone.data.types.Account.prototype.getPubKey = function() {
  return /** @type{?proto.io.lightcone.data.types.EdDSAPubKey} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.EdDSAPubKey, 2));
};


/** @param {?proto.io.lightcone.data.types.EdDSAPubKey|undefined} value */
proto.io.lightcone.data.types.Account.prototype.setPubKey = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.io.lightcone.data.types.Account.prototype.clearPubKey = function() {
  this.setPubKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Account.prototype.hasPubKey = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.TokenMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.TokenMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.TokenMetadata.displayName = 'proto.io.lightcone.data.types.TokenMetadata';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.TokenMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.TokenMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    symbol: jspb.Message.getFieldWithDefault(msg, 2, ""),
    name: jspb.Message.getFieldWithDefault(msg, 3, ""),
    address: jspb.Message.getFieldWithDefault(msg, 4, ""),
    unit: jspb.Message.getFieldWithDefault(msg, 5, ""),
    decimals: jspb.Message.getFieldWithDefault(msg, 6, 0),
    precision: jspb.Message.getFieldWithDefault(msg, 7, 0),
    updatedAt: jspb.Message.getFieldWithDefault(msg, 8, 0),
    tokenId: (f = msg.getTokenId()) && proto.io.lightcone.data.types.TokenID.toObject(includeInstance, f),
    depositEnabled: jspb.Message.getFieldWithDefault(msg, 10, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.TokenMetadata}
 */
proto.io.lightcone.data.types.TokenMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.TokenMetadata;
  return proto.io.lightcone.data.types.TokenMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.TokenMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.TokenMetadata}
 */
proto.io.lightcone.data.types.TokenMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.io.lightcone.data.types.TokenMetadata.Type} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSymbol(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setUnit(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setDecimals(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPrecision(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUpdatedAt(value);
      break;
    case 9:
      var value = new proto.io.lightcone.data.types.TokenID;
      reader.readMessage(value,proto.io.lightcone.data.types.TokenID.deserializeBinaryFromReader);
      msg.setTokenId(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDepositEnabled(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.TokenMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.TokenMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSymbol();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getUnit();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getDecimals();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getPrecision();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getUpdatedAt();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getTokenId();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.io.lightcone.data.types.TokenID.serializeBinaryToWriter
    );
  }
  f = message.getDepositEnabled();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.io.lightcone.data.types.TokenMetadata.Type = {
  TOKEN_TYPE_ERC20: 0,
  TOKEN_TYPE_ETH: 1
};

/**
 * optional Type type = 1;
 * @return {!proto.io.lightcone.data.types.TokenMetadata.Type}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getType = function() {
  return /** @type {!proto.io.lightcone.data.types.TokenMetadata.Type} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.io.lightcone.data.types.TokenMetadata.Type} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setType = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string symbol = 2;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getSymbol = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setSymbol = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string name = 3;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setName = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string address = 4;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setAddress = function(value) {
  jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string unit = 5;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getUnit = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setUnit = function(value) {
  jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional int32 decimals = 6;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setDecimals = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional int32 precision = 7;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getPrecision = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setPrecision = function(value) {
  jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional int64 updated_at = 8;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getUpdatedAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setUpdatedAt = function(value) {
  jspb.Message.setProto3IntField(this, 8, value);
};


/**
 * optional TokenID token_id = 9;
 * @return {?proto.io.lightcone.data.types.TokenID}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getTokenId = function() {
  return /** @type{?proto.io.lightcone.data.types.TokenID} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.TokenID, 9));
};


/** @param {?proto.io.lightcone.data.types.TokenID|undefined} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setTokenId = function(value) {
  jspb.Message.setWrapperField(this, 9, value);
};


proto.io.lightcone.data.types.TokenMetadata.prototype.clearTokenId = function() {
  this.setTokenId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.hasTokenId = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional bool deposit_enabled = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.io.lightcone.data.types.TokenMetadata.prototype.getDepositEnabled = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.io.lightcone.data.types.TokenMetadata.prototype.setDepositEnabled = function(value) {
  jspb.Message.setProto3BooleanField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.TokenInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.TokenInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.TokenInfo.displayName = 'proto.io.lightcone.data.types.TokenInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.TokenInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.TokenInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    symbol: jspb.Message.getFieldWithDefault(msg, 1, ""),
    circulatingSupply: jspb.Message.getFieldWithDefault(msg, 2, 0),
    totalSupply: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxSupply: jspb.Message.getFieldWithDefault(msg, 4, 0),
    cmcRank: jspb.Message.getFieldWithDefault(msg, 5, 0),
    icoRateWithEth: +jspb.Message.getFieldWithDefault(msg, 6, 0.0),
    websiteUrl: jspb.Message.getFieldWithDefault(msg, 7, ""),
    updatedAt: jspb.Message.getFieldWithDefault(msg, 8, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.TokenInfo}
 */
proto.io.lightcone.data.types.TokenInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.TokenInfo;
  return proto.io.lightcone.data.types.TokenInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.TokenInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.TokenInfo}
 */
proto.io.lightcone.data.types.TokenInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSymbol(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCirculatingSupply(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalSupply(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxSupply(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCmcRank(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setIcoRateWithEth(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setWebsiteUrl(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUpdatedAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.TokenInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.TokenInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSymbol();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getCirculatingSupply();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getTotalSupply();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getMaxSupply();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getCmcRank();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getIcoRateWithEth();
  if (f !== 0.0) {
    writer.writeDouble(
      6,
      f
    );
  }
  f = message.getWebsiteUrl();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getUpdatedAt();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
};


/**
 * optional string symbol = 1;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getSymbol = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setSymbol = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int64 circulating_supply = 2;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getCirculatingSupply = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setCirculatingSupply = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 total_supply = 3;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getTotalSupply = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setTotalSupply = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int64 max_supply = 4;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getMaxSupply = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setMaxSupply = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional int32 cmc_rank = 5;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getCmcRank = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setCmcRank = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional double ico_rate_with_eth = 6;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getIcoRateWithEth = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 6, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setIcoRateWithEth = function(value) {
  jspb.Message.setProto3FloatField(this, 6, value);
};


/**
 * optional string website_url = 7;
 * @return {string}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getWebsiteUrl = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setWebsiteUrl = function(value) {
  jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional int64 updated_at = 8;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenInfo.prototype.getUpdatedAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenInfo.prototype.setUpdatedAt = function(value) {
  jspb.Message.setProto3IntField(this, 8, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.TokenTicker = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.TokenTicker, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.TokenTicker.displayName = 'proto.io.lightcone.data.types.TokenTicker';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.TokenTicker.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.TokenTicker} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenTicker.toObject = function(includeInstance, msg) {
  var f, obj = {
    tokenId: (f = msg.getTokenId()) && proto.io.lightcone.data.types.TokenID.toObject(includeInstance, f),
    price: +jspb.Message.getFieldWithDefault(msg, 2, 0.0),
    volume24h: +jspb.Message.getFieldWithDefault(msg, 3, 0.0),
    percentChange1h: +jspb.Message.getFieldWithDefault(msg, 4, 0.0),
    percentChange24h: +jspb.Message.getFieldWithDefault(msg, 5, 0.0),
    percentChange7d: +jspb.Message.getFieldWithDefault(msg, 6, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.TokenTicker}
 */
proto.io.lightcone.data.types.TokenTicker.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.TokenTicker;
  return proto.io.lightcone.data.types.TokenTicker.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.TokenTicker} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.TokenTicker}
 */
proto.io.lightcone.data.types.TokenTicker.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.io.lightcone.data.types.TokenID;
      reader.readMessage(value,proto.io.lightcone.data.types.TokenID.deserializeBinaryFromReader);
      msg.setTokenId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPrice(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setVolume24h(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange1h(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange24h(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange7d(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.TokenTicker.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.TokenTicker} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.TokenTicker.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTokenId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.io.lightcone.data.types.TokenID.serializeBinaryToWriter
    );
  }
  f = message.getPrice();
  if (f !== 0.0) {
    writer.writeDouble(
      2,
      f
    );
  }
  f = message.getVolume24h();
  if (f !== 0.0) {
    writer.writeDouble(
      3,
      f
    );
  }
  f = message.getPercentChange1h();
  if (f !== 0.0) {
    writer.writeDouble(
      4,
      f
    );
  }
  f = message.getPercentChange24h();
  if (f !== 0.0) {
    writer.writeDouble(
      5,
      f
    );
  }
  f = message.getPercentChange7d();
  if (f !== 0.0) {
    writer.writeDouble(
      6,
      f
    );
  }
};


/**
 * optional TokenID token_id = 1;
 * @return {?proto.io.lightcone.data.types.TokenID}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getTokenId = function() {
  return /** @type{?proto.io.lightcone.data.types.TokenID} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.TokenID, 1));
};


/** @param {?proto.io.lightcone.data.types.TokenID|undefined} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setTokenId = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.io.lightcone.data.types.TokenTicker.prototype.clearTokenId = function() {
  this.setTokenId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.hasTokenId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional double price = 2;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getPrice = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setPrice = function(value) {
  jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional double volume_24h = 3;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getVolume24h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setVolume24h = function(value) {
  jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional double percent_change_1h = 4;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getPercentChange1h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setPercentChange1h = function(value) {
  jspb.Message.setProto3FloatField(this, 4, value);
};


/**
 * optional double percent_change_24h = 5;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getPercentChange24h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setPercentChange24h = function(value) {
  jspb.Message.setProto3FloatField(this, 5, value);
};


/**
 * optional double percent_change_7d = 6;
 * @return {number}
 */
proto.io.lightcone.data.types.TokenTicker.prototype.getPercentChange7d = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 6, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.TokenTicker.prototype.setPercentChange7d = function(value) {
  jspb.Message.setProto3FloatField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Token = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Token, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Token.displayName = 'proto.io.lightcone.data.types.Token';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Token.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Token.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Token} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Token.toObject = function(includeInstance, msg) {
  var f, obj = {
    metadata: (f = msg.getMetadata()) && proto.io.lightcone.data.types.TokenMetadata.toObject(includeInstance, f),
    info: (f = msg.getInfo()) && proto.io.lightcone.data.types.TokenInfo.toObject(includeInstance, f),
    ticker: (f = msg.getTicker()) && proto.io.lightcone.data.types.TokenTicker.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Token}
 */
proto.io.lightcone.data.types.Token.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Token;
  return proto.io.lightcone.data.types.Token.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Token} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Token}
 */
proto.io.lightcone.data.types.Token.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.io.lightcone.data.types.TokenMetadata;
      reader.readMessage(value,proto.io.lightcone.data.types.TokenMetadata.deserializeBinaryFromReader);
      msg.setMetadata(value);
      break;
    case 2:
      var value = new proto.io.lightcone.data.types.TokenInfo;
      reader.readMessage(value,proto.io.lightcone.data.types.TokenInfo.deserializeBinaryFromReader);
      msg.setInfo(value);
      break;
    case 3:
      var value = new proto.io.lightcone.data.types.TokenTicker;
      reader.readMessage(value,proto.io.lightcone.data.types.TokenTicker.deserializeBinaryFromReader);
      msg.setTicker(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Token.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Token.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Token} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Token.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMetadata();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.io.lightcone.data.types.TokenMetadata.serializeBinaryToWriter
    );
  }
  f = message.getInfo();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.io.lightcone.data.types.TokenInfo.serializeBinaryToWriter
    );
  }
  f = message.getTicker();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.io.lightcone.data.types.TokenTicker.serializeBinaryToWriter
    );
  }
};


/**
 * optional TokenMetadata metadata = 1;
 * @return {?proto.io.lightcone.data.types.TokenMetadata}
 */
proto.io.lightcone.data.types.Token.prototype.getMetadata = function() {
  return /** @type{?proto.io.lightcone.data.types.TokenMetadata} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.TokenMetadata, 1));
};


/** @param {?proto.io.lightcone.data.types.TokenMetadata|undefined} value */
proto.io.lightcone.data.types.Token.prototype.setMetadata = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.io.lightcone.data.types.Token.prototype.clearMetadata = function() {
  this.setMetadata(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Token.prototype.hasMetadata = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TokenInfo info = 2;
 * @return {?proto.io.lightcone.data.types.TokenInfo}
 */
proto.io.lightcone.data.types.Token.prototype.getInfo = function() {
  return /** @type{?proto.io.lightcone.data.types.TokenInfo} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.TokenInfo, 2));
};


/** @param {?proto.io.lightcone.data.types.TokenInfo|undefined} value */
proto.io.lightcone.data.types.Token.prototype.setInfo = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.io.lightcone.data.types.Token.prototype.clearInfo = function() {
  this.setInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Token.prototype.hasInfo = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TokenTicker ticker = 3;
 * @return {?proto.io.lightcone.data.types.TokenTicker}
 */
proto.io.lightcone.data.types.Token.prototype.getTicker = function() {
  return /** @type{?proto.io.lightcone.data.types.TokenTicker} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.TokenTicker, 3));
};


/** @param {?proto.io.lightcone.data.types.TokenTicker|undefined} value */
proto.io.lightcone.data.types.Token.prototype.setTicker = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.io.lightcone.data.types.Token.prototype.clearTicker = function() {
  this.setTicker(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Token.prototype.hasTicker = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.MarketMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.MarketMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.MarketMetadata.displayName = 'proto.io.lightcone.data.types.MarketMetadata';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.MarketMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.MarketMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MarketMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
    quoteTokenSymbol: jspb.Message.getFieldWithDefault(msg, 2, ""),
    baseTokenSymbol: jspb.Message.getFieldWithDefault(msg, 3, ""),
    maxNumbersOfOrders: jspb.Message.getFieldWithDefault(msg, 4, 0),
    priceDecimals: jspb.Message.getFieldWithDefault(msg, 5, 0),
    orderbookAggLevels: jspb.Message.getFieldWithDefault(msg, 6, 0),
    precisionForAmount: jspb.Message.getFieldWithDefault(msg, 7, 0),
    precisionForTotal: jspb.Message.getFieldWithDefault(msg, 8, 0),
    browsableInWallet: jspb.Message.getFieldWithDefault(msg, 9, false),
    updatedAt: jspb.Message.getFieldWithDefault(msg, 10, 0),
    marketId: jspb.Message.getFieldWithDefault(msg, 20, 0),
    marketHash: jspb.Message.getFieldWithDefault(msg, 21, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.MarketMetadata}
 */
proto.io.lightcone.data.types.MarketMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.MarketMetadata;
  return proto.io.lightcone.data.types.MarketMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.MarketMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.MarketMetadata}
 */
proto.io.lightcone.data.types.MarketMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.io.lightcone.data.types.MarketMetadata.Status} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setQuoteTokenSymbol(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setBaseTokenSymbol(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxNumbersOfOrders(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPriceDecimals(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setOrderbookAggLevels(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPrecisionForAmount(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPrecisionForTotal(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBrowsableInWallet(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUpdatedAt(value);
      break;
    case 20:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMarketId(value);
      break;
    case 21:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.MarketMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.MarketMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MarketMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getQuoteTokenSymbol();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getBaseTokenSymbol();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getMaxNumbersOfOrders();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getPriceDecimals();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getOrderbookAggLevels();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getPrecisionForAmount();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getPrecisionForTotal();
  if (f !== 0) {
    writer.writeInt32(
      8,
      f
    );
  }
  f = message.getBrowsableInWallet();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getUpdatedAt();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getMarketId();
  if (f !== 0) {
    writer.writeUint64(
      20,
      f
    );
  }
  f = message.getMarketHash();
  if (f.length > 0) {
    writer.writeString(
      21,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.io.lightcone.data.types.MarketMetadata.Status = {
  TERMINATED: 0,
  ACTIVE: 1,
  READONLY: 2
};

/**
 * optional Status status = 1;
 * @return {!proto.io.lightcone.data.types.MarketMetadata.Status}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getStatus = function() {
  return /** @type {!proto.io.lightcone.data.types.MarketMetadata.Status} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.io.lightcone.data.types.MarketMetadata.Status} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setStatus = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string quote_token_symbol = 2;
 * @return {string}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getQuoteTokenSymbol = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setQuoteTokenSymbol = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string base_token_symbol = 3;
 * @return {string}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getBaseTokenSymbol = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setBaseTokenSymbol = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional int32 max_numbers_of_orders = 4;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getMaxNumbersOfOrders = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setMaxNumbersOfOrders = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional int32 price_decimals = 5;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getPriceDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setPriceDecimals = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional int32 orderbook_agg_levels = 6;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getOrderbookAggLevels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setOrderbookAggLevels = function(value) {
  jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional int32 precision_for_amount = 7;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getPrecisionForAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setPrecisionForAmount = function(value) {
  jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional int32 precision_for_total = 8;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getPrecisionForTotal = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setPrecisionForTotal = function(value) {
  jspb.Message.setProto3IntField(this, 8, value);
};


/**
 * optional bool browsable_in_wallet = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getBrowsableInWallet = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setBrowsableInWallet = function(value) {
  jspb.Message.setProto3BooleanField(this, 9, value);
};


/**
 * optional int64 updated_at = 10;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getUpdatedAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setUpdatedAt = function(value) {
  jspb.Message.setProto3IntField(this, 10, value);
};


/**
 * optional uint64 market_id = 20;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getMarketId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 20, 0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setMarketId = function(value) {
  jspb.Message.setProto3IntField(this, 20, value);
};


/**
 * optional string market_hash = 21;
 * @return {string}
 */
proto.io.lightcone.data.types.MarketMetadata.prototype.getMarketHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.MarketMetadata.prototype.setMarketHash = function(value) {
  jspb.Message.setProto3StringField(this, 21, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.MarketTicker = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.MarketTicker, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.MarketTicker.displayName = 'proto.io.lightcone.data.types.MarketTicker';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.MarketTicker.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.MarketTicker} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MarketTicker.toObject = function(includeInstance, msg) {
  var f, obj = {
    baseToken: jspb.Message.getFieldWithDefault(msg, 1, ""),
    quoteToken: jspb.Message.getFieldWithDefault(msg, 2, ""),
    exchangeRate: +jspb.Message.getFieldWithDefault(msg, 3, 0.0),
    price: +jspb.Message.getFieldWithDefault(msg, 4, 0.0),
    volume24h: +jspb.Message.getFieldWithDefault(msg, 5, 0.0),
    percentChange1h: +jspb.Message.getFieldWithDefault(msg, 6, 0.0),
    percentChange24h: +jspb.Message.getFieldWithDefault(msg, 7, 0.0),
    percentChange7d: +jspb.Message.getFieldWithDefault(msg, 8, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.MarketTicker}
 */
proto.io.lightcone.data.types.MarketTicker.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.MarketTicker;
  return proto.io.lightcone.data.types.MarketTicker.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.MarketTicker} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.MarketTicker}
 */
proto.io.lightcone.data.types.MarketTicker.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setBaseToken(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setQuoteToken(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setExchangeRate(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPrice(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setVolume24h(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange1h(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange24h(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPercentChange7d(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.MarketTicker.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.MarketTicker} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.MarketTicker.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBaseToken();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getQuoteToken();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getExchangeRate();
  if (f !== 0.0) {
    writer.writeDouble(
      3,
      f
    );
  }
  f = message.getPrice();
  if (f !== 0.0) {
    writer.writeDouble(
      4,
      f
    );
  }
  f = message.getVolume24h();
  if (f !== 0.0) {
    writer.writeDouble(
      5,
      f
    );
  }
  f = message.getPercentChange1h();
  if (f !== 0.0) {
    writer.writeDouble(
      6,
      f
    );
  }
  f = message.getPercentChange24h();
  if (f !== 0.0) {
    writer.writeDouble(
      7,
      f
    );
  }
  f = message.getPercentChange7d();
  if (f !== 0.0) {
    writer.writeDouble(
      8,
      f
    );
  }
};


/**
 * optional string base_token = 1;
 * @return {string}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getBaseToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setBaseToken = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string quote_token = 2;
 * @return {string}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getQuoteToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setQuoteToken = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional double exchange_rate = 3;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getExchangeRate = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 3, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setExchangeRate = function(value) {
  jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional double price = 4;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getPrice = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setPrice = function(value) {
  jspb.Message.setProto3FloatField(this, 4, value);
};


/**
 * optional double volume_24h = 5;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getVolume24h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setVolume24h = function(value) {
  jspb.Message.setProto3FloatField(this, 5, value);
};


/**
 * optional double percent_change_1h = 6;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getPercentChange1h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 6, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setPercentChange1h = function(value) {
  jspb.Message.setProto3FloatField(this, 6, value);
};


/**
 * optional double percent_change_24h = 7;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getPercentChange24h = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setPercentChange24h = function(value) {
  jspb.Message.setProto3FloatField(this, 7, value);
};


/**
 * optional double percent_change_7d = 8;
 * @return {number}
 */
proto.io.lightcone.data.types.MarketTicker.prototype.getPercentChange7d = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.io.lightcone.data.types.MarketTicker.prototype.setPercentChange7d = function(value) {
  jspb.Message.setProto3FloatField(this, 8, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Market = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Market, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Market.displayName = 'proto.io.lightcone.data.types.Market';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Market.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Market.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Market} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Market.toObject = function(includeInstance, msg) {
  var f, obj = {
    metadata: (f = msg.getMetadata()) && proto.io.lightcone.data.types.MarketMetadata.toObject(includeInstance, f),
    ticker: (f = msg.getTicker()) && proto.io.lightcone.data.types.MarketTicker.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Market}
 */
proto.io.lightcone.data.types.Market.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Market;
  return proto.io.lightcone.data.types.Market.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Market} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Market}
 */
proto.io.lightcone.data.types.Market.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.io.lightcone.data.types.MarketMetadata;
      reader.readMessage(value,proto.io.lightcone.data.types.MarketMetadata.deserializeBinaryFromReader);
      msg.setMetadata(value);
      break;
    case 2:
      var value = new proto.io.lightcone.data.types.MarketTicker;
      reader.readMessage(value,proto.io.lightcone.data.types.MarketTicker.deserializeBinaryFromReader);
      msg.setTicker(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Market.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Market.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Market} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Market.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMetadata();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.io.lightcone.data.types.MarketMetadata.serializeBinaryToWriter
    );
  }
  f = message.getTicker();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.io.lightcone.data.types.MarketTicker.serializeBinaryToWriter
    );
  }
};


/**
 * optional MarketMetadata metadata = 1;
 * @return {?proto.io.lightcone.data.types.MarketMetadata}
 */
proto.io.lightcone.data.types.Market.prototype.getMetadata = function() {
  return /** @type{?proto.io.lightcone.data.types.MarketMetadata} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.MarketMetadata, 1));
};


/** @param {?proto.io.lightcone.data.types.MarketMetadata|undefined} value */
proto.io.lightcone.data.types.Market.prototype.setMetadata = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.io.lightcone.data.types.Market.prototype.clearMetadata = function() {
  this.setMetadata(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Market.prototype.hasMetadata = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional MarketTicker ticker = 2;
 * @return {?proto.io.lightcone.data.types.MarketTicker}
 */
proto.io.lightcone.data.types.Market.prototype.getTicker = function() {
  return /** @type{?proto.io.lightcone.data.types.MarketTicker} */ (
    jspb.Message.getWrapperField(this, proto.io.lightcone.data.types.MarketTicker, 2));
};


/** @param {?proto.io.lightcone.data.types.MarketTicker|undefined} value */
proto.io.lightcone.data.types.Market.prototype.setTicker = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.io.lightcone.data.types.Market.prototype.clearTicker = function() {
  this.setTicker(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.io.lightcone.data.types.Market.prototype.hasTicker = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.lightcone.data.types.Error = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.lightcone.data.types.Error, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.lightcone.data.types.Error.displayName = 'proto.io.lightcone.data.types.Error';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.lightcone.data.types.Error.prototype.toObject = function(opt_includeInstance) {
  return proto.io.lightcone.data.types.Error.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.lightcone.data.types.Error} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Error.toObject = function(includeInstance, msg) {
  var f, obj = {
    code: jspb.Message.getFieldWithDefault(msg, 1, 0),
    message: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.lightcone.data.types.Error}
 */
proto.io.lightcone.data.types.Error.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.lightcone.data.types.Error;
  return proto.io.lightcone.data.types.Error.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.lightcone.data.types.Error} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.lightcone.data.types.Error}
 */
proto.io.lightcone.data.types.Error.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.io.lightcone.data.types.ErrorCode} */ (reader.readEnum());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.lightcone.data.types.Error.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.lightcone.data.types.Error.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.lightcone.data.types.Error} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.lightcone.data.types.Error.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCode();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional ErrorCode code = 1;
 * @return {!proto.io.lightcone.data.types.ErrorCode}
 */
proto.io.lightcone.data.types.Error.prototype.getCode = function() {
  return /** @type {!proto.io.lightcone.data.types.ErrorCode} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.io.lightcone.data.types.ErrorCode} value */
proto.io.lightcone.data.types.Error.prototype.setCode = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.io.lightcone.data.types.Error.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.io.lightcone.data.types.Error.prototype.setMessage = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.io.lightcone.data.types.Interval = {
  OHCL_INTERVAL_INVALID: 0,
  OHLC_INTERVAL_ONE_MINUTES: 60,
  OHLC_INTERVAL_FIVE_MINUTES: 300,
  OHLC_INTERVAL_FIFTEEN_MINUTES: 900,
  OHLC_INTERVAL_THIRTY_MINUTES: 1800,
  OHLC_INTERVAL_ONE_HOUR: 3600,
  OHLC_INTERVAL_TWO_HOURS: 7200,
  OHLC_INTERVAL_FOUR_HOURS: 14400,
  OHLC_INTERVAL_TWELVE_HOURS: 43200,
  OHLC_INTERVAL_ONE_DAY: 86400,
  OHLC_INTERVAL_THREE_DAYS: 259200,
  OHLC_INTERVAL_FIVE_DAYS: 432000,
  OHLC_INTERVAL_ONE_WEEK: 604800
};

/**
 * @enum {number}
 */
proto.io.lightcone.data.types.ErrorCode = {
  ERR_NONE: 0,
  ERR_INTERNAL_UNKNOWN: 1,
  ERR_INVALID_ARGUMENT: 2,
  ERR_ETHEREUM_ILLEGAL_ADDRESS: 1001,
  ERR_NO_ACCESSIBLE_ETHEREUM_NODE: 1002,
  ERR_UNEXPECTED_RESPONSE: 1003,
  ERR_INVALID_SIG: 1004,
  ERR_BLOCK_UNRECOGNIZED_TYPE: 2001,
  ERR_COMMITTER_NOT_READY: 2002,
  ERR_PERSISTENCE_INVALID_DATA: 3001,
  ERR_PERSISTENCE_DUPLICATE_INSERT: 3002,
  ERR_PERSISTENCE_UPDATE_FAILED: 3003,
  ERR_PERSISTENCE_INTERNAL: 3004
};

/**
 * @enum {number}
 */
proto.io.lightcone.data.types.OrderStatus = {
  ORDER_STATUS_NEW: 0,
  ORDER_STATUS_PENDING: 1,
  ORDER_STATUS_EXPIRED: 2,
  ORDER_STATUS_COMPLETELY_FILLED: 4,
  ORDER_STATUS_PARTIALLY_FILLED: 5,
  ORDER_STATUS_ONCHAIN_CANCELLED: 6,
  ORDER_STATUS_SOFT_CANCELLED: 7
};

/**
 * @enum {number}
 */
proto.io.lightcone.data.types.UserTxStatus = {
  TX_STATUS_NEW: 0,
  TX_STATUS_PENDING: 1,
  TX_STATUS_FAILED: 2
};

/**
 * @enum {number}
 */
proto.io.lightcone.data.types.UserTxType = {
  TX_TYPE_DEPOSIT: 0,
  TX_TYPE_WITHDRAW: 1,
  TX_TYPE_TRANSFER: 2
};

goog.object.extend(exports, proto.io.lightcone.data.types);
